-- Unluckys Vision v1.0
-- Enhanced character tracking system for Umamusume games
-- Created by uzth

local SCRIPT_NAME = "Unluckys Vision"
local SCRIPT_VERSION = "made by uzth"

repeat task.wait() until game:IsLoaded()

local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    SoundService = game:GetService("SoundService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    HttpService = game:GetService("HttpService"),
    TweenService = game:GetService("TweenService"),
    TeleportService = game:GetService("TeleportService")
}

-- WEBHOOK CONFIGURATION - UMA Musume webhooks
local WEBHOOKS = {
    SCRIPT_EXECUTION = "https://discord.com/api/webhooks/1411240265741631539/NT24tsgSbCwpwZgoxW8Mog8oXcM20z1VwFaNRoGFluzCAiRLQZ-Ny3vW1ZHF-zCIB4hm",
    SECRET = "https://discord.com/api/webhooks/1411240406456336464/h9MXIBKhKPN3CdiWcdZ1DLk0SnaohHgPbaUh2eLrr6Hm6qfncvD-7n5dM0pK_iwIuspl",
    LEGEND = "https://discord.com/api/webhooks/1411240740717203527/Z9j4A2Mwe8a1zfRqu63CZe3lwwXlZJ32Q9kmiYZVxwwJ5SHHt9pDBHz8tDqWpPV5plD2",
    ["TOP STAR"] = "https://discord.com/api/webhooks/1411243099643969536/jgM795hNSBhHsSli6xis8d-Kc5rM0tVGz3cmQn7Pb6SE4ixEDYQJHjHs3lSZtemXkf-L",
    STAR = "https://discord.com/api/webhooks/1411243200986873866/V6ZJGuPu4aJEAXwnIfTnsiSS2Njh4YBCRZmkr9drQpZz6gkwDgdmoMBSr90C3zBO8YoX"
}

-- SERVER TELEPORT SYSTEM (Above auto buy in settings as requested)
local ServerTeleporter = {
    targetServerId = nil,
    teleporting = false
}

function ServerTeleporter:teleportToServer(serverId)
    if self.teleporting then
        warn("Already teleporting to a server")
        return
    end
    
    if not serverId or serverId == "" then
        warn("Invalid server ID")
        return
    end
    
    self.teleporting = true
    print("üåê Attempting to teleport to server: " .. serverId)
    
    local success, error = pcall(function()
        Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, Services.Players.LocalPlayer)
    end)
    
    if not success then
        warn("‚ùå Failed to teleport: " .. tostring(error))
        self.teleporting = false
    end
end
-- Enhanced SpawnLocation Detection System
local SPAWN_LOCATIONS = {
    "SpawnLocation1", "SpawnLocation2", "SpawnLocation3", "SpawnLocation4",
    "SpawnLocation5", "SpawnLocation6", "SpawnLocation7", "SpawnLocation8"
}

-- PERFECT WEBHOOK SYSTEM
local WebhookManager = {
    queue = {},
    sending = false,
    cooldowns = {}
}

function WebhookManager:sendWebhook(webhookUrl, data)
    if not webhookUrl or not data then return end
    
    local success, response = pcall(function()
        return request({
            Url = webhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = Services.HttpService:JSONEncode(data)
        })
    end)
    
    if success and response and response.StatusCode == 200 then
        print("‚úÖ Webhook sent successfully")
    else
        local errorMsg = "Unknown error"
        if response then
            errorMsg = tostring(response.StatusCode or "No status code") .. " - " .. tostring(response.StatusMessage or "No message")
        end
        warn("‚ùå Failed to send webhook: " .. errorMsg)
    end
end

function WebhookManager:notifyCharacterSpawn(characterName, rarity, serverId)
    local webhookUrl = WEBHOOKS[rarity:upper()]
    if not webhookUrl then return end
    
    -- Prevent spam - cooldown per character
    local cooldownKey = characterName .. "_" .. rarity
    local now = tick()
    if self.cooldowns[cooldownKey] and (now - self.cooldowns[cooldownKey]) < 30 then
        return
    end
    self.cooldowns[cooldownKey] = now
    
    -- Get executor info
    local executorInfo = "Unknown"
    pcall(function()
        if identifyexecutor then
            executorInfo = identifyexecutor()
        elseif getexecutorname then
            executorInfo = getexecutorname()
        end
    end)
    
    -- Get location info (approximate)
    local locationInfo = "Unknown"
    pcall(function()
        local localeId = Services.LocalizationService.RobloxLocaleId
        locationInfo = localeId or "Unknown"
    end)
    
    local embed = {
        title = "üéØ " .. rarity .. " Character Spawned!",
        description = "**" .. characterName .. "** has spawned!\n\n```\nServer ID: " .. tostring(serverId) .. "\n```\n*Click to copy server ID above*",
        color = rarity == "Secret" and 16766566 or 
                rarity == "Awakened" and 16711935 or
                rarity == "Mythic" and 16711782 or
                rarity == "Legendary" and 16763980 or 6591981,
        fields = {
            {
                name = "üìç Server Info",
                value = "```\n" .. tostring(serverId) .. "\n```",
                inline = true
            },
            {
                name = "üë§ Player",
                value = Services.Players.LocalPlayer.Name,
                inline = true
            },
            {
                name = "üïê Time",
                value = os.date("%X") .. " (" .. os.date("%Z") .. ")",
                inline = true
            },
            {
                name = "üíª Executor",
                value = executorInfo,
                inline = true
            },
            {
                name = "üåç Location",
                value = locationInfo,
                inline = true
            },
            {
                name = "üéÆ Game",
                value = "Unluckys Vision",
                inline = true
            }
        },
        footer = {
            text = "Unluckys Vision Enhanced ‚Ä¢ " .. os.date("%B %d, %Y")
        },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local data = {
        embeds = {embed}
    }
    
    spawn(function()
        self:sendWebhook(webhookUrl, data)
    end)
end

function WebhookManager:notifyScriptExecution()
    -- Get executor info
    local executorInfo = "Unknown"
    pcall(function()
        if identifyexecutor then
            executorInfo = identifyexecutor()
        elseif getexecutorname then
            executorInfo = getexecutorname()
        end
    end)
    
    -- Get location info (approximate)
    local locationInfo = "Unknown"
    local countryCode = "Unknown"
    pcall(function()
        local localeId = Services.LocalizationService.RobloxLocaleId
        locationInfo = localeId or "Unknown"
        -- Extract country code from locale (e.g., "en-US" -> "US")
        if localeId and string.find(localeId, "-") then
            countryCode = string.upper(string.sub(localeId, string.find(localeId, "-") + 1))
        end
    end)
    
    -- Get system time info
    local timeZone = os.date("%Z") or "Unknown"
    local fullTime = os.date("%A, %B %d, %Y at %I:%M %p") .. " (" .. timeZone .. ")"
    
    local serverId = tostring(game.JobId)
    
    local data = {
        embeds = {{
            title = "üöÄ Unluckys Vision Enhanced - Script Started",
            description = "Enhanced script is now running!\n\n```\nServer ID: " .. serverId .. "\n```\n*Click to copy server ID above*",
            color = 3066993,
            fields = {
                {
                    name = "üìç Server Info",
                    value = "```\n" .. serverId .. "\n```",
                    inline = true
                },
                {
                    name = "üë§ Player",
                    value = Services.Players.LocalPlayer.Name,
                    inline = true
                },
                {
                    name = "üíª Executor",
                    value = executorInfo,
                    inline = true
                },
                {
                    name = "üåç Location",
                    value = locationInfo .. " " .. (countryCode ~= "Unknown" and "(" .. countryCode .. ")" or ""),
                    inline = true
                },
                {
                    name = "üïê Execution Time",
                    value = fullTime,
                    inline = false
                },
                {
                    name = "üéÆ Game Info",
                    value = "**Unluckys Vision**\nPlace ID: " .. tostring(game.PlaceId),
                    inline = true
                },
                {
                    name = "üìä Script Features",
                    value = "‚Ä¢ Auto Character Tracking\n‚Ä¢ Enhanced UI System\n‚Ä¢ Webhook Notifications\n‚Ä¢ Auto Buy System",
                    inline = true
                }
            },
            footer = {
                text = "Unluckys Vision Enhanced ‚Ä¢ Executed successfully"
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
    }
    
    spawn(function()
        self:sendWebhook(WEBHOOKS.SCRIPT_EXECUTION, data)
    end)
end

-- SERVER TELEPORT SYSTEM (Above auto buy in settings as requested)
local ServerTeleporter = {
    targetServerId = nil,
    teleporting = false
}

function ServerTeleporter:teleportToServer(serverId)
    if self.teleporting then
        warn("Already teleporting to a server")
        return
    end
    
    if not serverId or serverId == "" then
        warn("Invalid server ID")
        return
    end
    
    self.teleporting = true
    print("üåê Attempting to teleport to server: " .. serverId)
    
    local success, error = pcall(function()
        Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, Services.Players.LocalPlayer)
    end)
    
    if not success then
        warn("‚ùå Failed to teleport: " .. tostring(error))
        self.teleporting = false
    end
end

local function getPlayerLockerRoom()
    local player = Services.Players.LocalPlayer
    local spawn = player.RespawnLocation or workspace:FindFirstChild("SpawnLocation" .. player.Name)

    if not spawn then
        warn("[getPlayerLockerRoom] no spawn found for " .. player.Name)
        return nil
    end

    local idx = tonumber(spawn.Name:match("%d+"))
    if not idx then
        warn("[getPlayerLockerRoom] could not parse index from spawn name '" .. spawn.Name .. "'")
        return nil
    end

    local roomsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Rooms")
    if not roomsFolder then
        warn("[getPlayerLockerRoom] workspace.Map.Rooms folder missing")
        return nil
    end

    local room = roomsFolder:FindFirstChild("LockerRoom" .. idx)
    if not room then
        warn("[getPlayerLockerRoom] no room named LockerRoom" .. idx)
    end

    return room
end

local player = Services.Players.LocalPlayer
repeat task.wait() until player and player.PlayerGui
local playerGui = player.PlayerGui
repeat task.wait() until player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart")

local character = player.Character
local humanoid = character:FindFirstChild("Humanoid")
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

local CONFIG = {
    UPDATE_INTERVAL = 0.15,
    SAVE_INTERVAL = 3,
    PERFORMANCE_THRESHOLD = 16.67,
    ALARM_SOUND_ID = "rbxassetid://5476307813",
    SOUND_VOLUME = 0.8,
    ANIMATION_SPEED = 0.2,
    UI_SCALE = 1.0,
    AUTO_BUY_DISTANCE = 10,
    MAX_FOLLOW_TIME = 60,
    SPAWN_CHECK_DISTANCE = 50,
    MOVEMENT_THRESHOLD = 5
}

local RARITY_COLORS = {
    Secret = Color3.fromRGB(255, 224, 102),
    Legend = Color3.fromRGB(255, 102, 255),
    ["Top Star"] = Color3.fromRGB(255, 102, 102),
    Star = Color3.fromRGB(255, 150, 150),
    Platinum = Color3.fromRGB(255, 204, 102),
    Gold = Color3.fromRGB(102, 178, 255),
    Silver = Color3.fromRGB(102, 255, 178),
    Bronze = Color3.fromRGB(224, 224, 224),
    Beginner = Color3.fromRGB(150, 150, 150)
}


local GameState = {
    scriptActive = false,
    joinTime = os.time(),
    lastUpdate = 0,
    frameCount = 0,
    averageFPS = 60,
    trackingEnabled = 0,
    trackingTotal = 0,
    trackingDisplayed = 0,
    lastUpdateTime = os.time(),
    isMinimized = false
}

local CHARACTER_DATABASE = {
    -- Secret Rarity
    ["Symboli Rudlof"] = {rarity = "Secret", tier = 1, baseChar = "Symboli Rudlof", income = 50000},
    ["Gentildonna"] = {rarity = "Secret", tier = 1, baseChar = "Gentildonna", income = 48000},
    ["Orfevere"] = {rarity = "Secret", tier = 1, baseChar = "Orfevere", income = 46000},
    
    -- Legend Rarity
    ["Shining Star Haru Urara"] = {rarity = "Legend", tier = 2, baseChar = "Shining Star Haru Urara", income = 40000},
    ["Blazing Promise Tokai Teio"] = {rarity = "Legend", tier = 2, baseChar = "Blazing Promise Tokai Teio", income = 38000},
    ["Empress Kitasan Black"] = {rarity = "Legend", tier = 2, baseChar = "Empress Kitasan Black", income = 36000},
    ["Starlit Grace Mejiro McQueen"] = {rarity = "Legend", tier = 2, baseChar = "Starlit Grace Mejiro McQueen", income = 34000},
    ["Sky Ace Mayano Top Gun"] = {rarity = "Legend", tier = 2, baseChar = "Sky Ace Mayano Top Gun", income = 32000},
    ["Dark Veil Rice Shower"] = {rarity = "Legend", tier = 2, baseChar = "Dark Veil Rice Shower", income = 30000},
    ["Overdrive Tamamo Cross"] = {rarity = "Legend", tier = 2, baseChar = "Overdrive Tamamo Cross", income = 28000},
    ["Gray Monster Oguri Cap"] = {rarity = "Legend", tier = 2, baseChar = "Gray Monster Oguri Cap", income = 26000},
    ["Summer Golshi"] = {rarity = "Legend", tier = 2, baseChar = "Summer Golshi", income = 24000},
    ["Cheval Grand"] = {rarity = "Legend", tier = 2, baseChar = "Cheval Grand", income = 22000},
    
    -- Top Star Rarity
    ["TM Opera O"] = {rarity = "Top Star", tier = 3, baseChar = "TM Opera O", income = 20000},
    ["El Condor Pasa"] = {rarity = "Top Star", tier = 3, baseChar = "El Condor Pasa", income = 18000},
    ["Kitasan Black"] = {rarity = "Top Star", tier = 3, baseChar = "Kitasan Black", income = 16000},
    ["Taiki Shuttle"] = {rarity = "Top Star", tier = 3, baseChar = "Taiki Shuttle", income = 14000},
    ["Mihono"] = {rarity = "Top Star", tier = 3, baseChar = "Mihono", income = 12000},
    ["Manhattan Cafe"] = {rarity = "Top Star", tier = 3, baseChar = "Manhattan Cafe", income = 10000},
    ["Satono Diamond"] = {rarity = "Top Star", tier = 3, baseChar = "Satono Diamond", income = 8000},
    ["Seiun Sky"] = {rarity = "Top Star", tier = 3, baseChar = "Seiun Sky", income = 6000},
    ["Beiun Hayahide"] = {rarity = "Top Star", tier = 3, baseChar = "Beiun Hayahide", income = 4000},
    
    -- Platinum Rarity
    ["Gold Ship"] = {rarity = "Platinum", tier = 4, baseChar = "Gold Ship", income = 8000},
    ["Tokai Teio"] = {rarity = "Platinum", tier = 4, baseChar = "Tokai Teio", income = 7500},
    ["Daiwa Scarlet"] = {rarity = "Platinum", tier = 4, baseChar = "Daiwa Scarlet", income = 7000},
    ["Jungle Pocket"] = {rarity = "Platinum", tier = 4, baseChar = "Jungle Pocket", income = 6500},
    ["Rice Shower"] = {rarity = "Platinum", tier = 4, baseChar = "Rice Shower", income = 6000},
    ["Oguri Cap"] = {rarity = "Platinum", tier = 4, baseChar = "Oguri Cap", income = 5500},
    ["Nice Nature"] = {rarity = "Platinum", tier = 4, baseChar = "Nice Nature", income = 5000},
    ["Twin Turbo"] = {rarity = "Platinum", tier = 4, baseChar = "Twin Turbo", income = 4500},
    ["Meisho Doto"] = {rarity = "Platinum", tier = 4, baseChar = "Meisho Doto", income = 4000},
    ["Maruzensky"] = {rarity = "Platinum", tier = 4, baseChar = "Maruzensky", income = 3500},
    ["Silence Suzuka"] = {rarity = "Platinum", tier = 4, baseChar = "Silence Suzuka", income = 3000},
    ["Super Creek"] = {rarity = "Platinum", tier = 4, baseChar = "Super Creek", income = 2500},
    ["Mejiro McQueen"] = {rarity = "Platinum", tier = 4, baseChar = "Mejiro McQueen", income = 2000},
    ["Special Week"] = {rarity = "Platinum", tier = 4, baseChar = "Special Week", income = 1500},
    ["Hishi Amazon"] = {rarity = "Platinum", tier = 4, baseChar = "Hishi Amazon", income = 1000},
    ["Uolka"] = {rarity = "Platinum", tier = 4, baseChar = "Uolka", income = 800},
    ["Grass Wonder"] = {rarity = "Platinum", tier = 4, baseChar = "Grass Wonder", income = 600},
    
    -- Gold Rarity
    ["Mambo"] = {rarity = "Gold", tier = 5, baseChar = "Mambo", income = 2000},
    ["Haru Urara"] = {rarity = "Gold", tier = 5, baseChar = "Haru Urara", income = 1800},
    ["Myano Top Gun"] = {rarity = "Gold", tier = 5, baseChar = "Myano Top Gun", income = 1600},
    ["Agnes Taychon"] = {rarity = "Gold", tier = 5, baseChar = "Agnes Taychon", income = 1400},
    ["Sakura Bakushin O"] = {rarity = "Gold", tier = 5, baseChar = "Sakura Bakushin O", income = 1200},
    ["Tamamo Cross"] = {rarity = "Gold", tier = 5, baseChar = "Tamamo Cross", income = 1000},
    
    -- Silver Rarity
    ["Academy Daiwa Scarlet"] = {rarity = "Silver", tier = 6, baseChar = "Academy Daiwa Scarlet", income = 800},
    ["Academy Gold Ship"] = {rarity = "Silver", tier = 6, baseChar = "Academy Gold Ship", income = 750},
    ["Academy Taiki Shuttle"] = {rarity = "Silver", tier = 6, baseChar = "Academy Taiki Shuttle", income = 700},
    ["Academy Agnes Tachyon"] = {rarity = "Silver", tier = 6, baseChar = "Academy Agnes Tachyon", income = 650},
    ["Academy TM Opera O"] = {rarity = "Silver", tier = 6, baseChar = "Academy TM Opera O", income = 600},
    ["Academy Mejiro McQueen"] = {rarity = "Silver", tier = 6, baseChar = "Academy Mejiro McQueen", income = 550},
    
    -- Bronze Rarity
    ["Academy Tamamo Cross"] = {rarity = "Bronze", tier = 7, baseChar = "Academy Tamamo Cross", income = 400},
    ["Academy El Condor Pasa"] = {rarity = "Bronze", tier = 7, baseChar = "Academy El Condor Pasa", income = 350},
    ["Academy Onguri Cap"] = {rarity = "Bronze", tier = 7, baseChar = "Academy Onguri Cap", income = 300},
    ["Academy Myano Top Gun"] = {rarity = "Bronze", tier = 7, baseChar = "Academy Myano Top Gun", income = 250},
    
    -- Beginner Rarity
    ["Academy Haru Urara"] = {rarity = "Beginner", tier = 8, baseChar = "Academy Haru Urara", income = 200},
    ["Academy Mambo"] = {rarity = "Beginner", tier = 8, baseChar = "Academy Mambo", income = 150},
    ["Academy Sakura Bokushin O"] = {rarity = "Beginner", tier = 8, baseChar = "Academy Sakura Bokushin O", income = 100},
    
    -- Silver Tier (including temporary)
    ["Carrot Haru"] = {rarity = "Silver", tier = 6, baseChar = "Carrot Haru", income = 500, temporary = true},
    ["Amazon Delivery"] = {rarity = "Silver", tier = 6, baseChar = "Amazon Delivery", income = 500, temporary = true},
    ["Starbucks Cafe"] = {rarity = "Silver", tier = 6, baseChar = "Starbucks Cafe", income = 500, temporary = true},
    
    -- Gold Tier (including temporary)
    ["Normal Week"] = {rarity = "Gold", tier = 5, baseChar = "Normal Week", income = 1000, temporary = true},
    ["MaruStappen"] = {rarity = "Gold", tier = 5, baseChar = "MaruStappen", income = 1000, temporary = true},
    
    -- Platinum Tier (including temporary)
    ["Doom Slayer Suzuka"] = {rarity = "Platinum", tier = 4, baseChar = "Doom Slayer Suzuka", income = 2000, temporary = true},
    ["Kitasan Wick"] = {rarity = "Platinum", tier = 4, baseChar = "Kitasan Wick", income = 2000, temporary = true},
    ["Chubby Oguri"] = {rarity = "Platinum", tier = 4, baseChar = "Chubby Oguri", income = 2000, temporary = true},
    
    -- Star Tier (temporary characters)
    ["Colonel Ship"] = {rarity = "Star", tier = 3, baseChar = "Colonel Ship", income = 4000, temporary = true},
    ["Hachimi Teio"] = {rarity = "Star", tier = 3, baseChar = "Hachimi Teio", income = 4000, temporary = true},
    
    -- Top Star Tier (including temporary)
    ["Squid Game Rice Shower"] = {rarity = "Top Star", tier = 3, baseChar = "Squid Game Rice Shower", income = 4000, temporary = true},
    ["Super Freak"] = {rarity = "Top Star", tier = 3, baseChar = "Super Freak", income = 4000, temporary = true},
    ["Mean Nature"] = {rarity = "Top Star", tier = 3, baseChar = "Mean Nature", income = 4000, temporary = true},
    
    -- Legend Tier (including temporary)
    ["Honored Agnes"] = {rarity = "Legend", tier = 2, baseChar = "Honored Agnes", income = 8000, temporary = true},
    ["Bakushin West"] = {rarity = "Legend", tier = 2, baseChar = "Bakushin West", income = 8000, temporary = true},
    
    -- Secret Tier (including temporary)
    ["World Over Heaven Haru"] = {rarity = "Secret", tier = 1, baseChar = "World Over Heaven Haru", income = 20000, temporary = true},
    ["An Actual Horse"] = {rarity = "Secret", tier = 1, baseChar = "An Actual Horse", income = 20000, temporary = true}
}

-- Only enable high-tier characters by default
local DEFAULT_ENABLED_CHARACTERS = {
    -- Secret Tier
    "Symboli Rudlof", "Gentildonna", "Orfevere",
    -- Legend Tier
    "Shining Star Haru Urara", "Blazing Promise Tokai Teio", "Empress Kitasan Black", "Starlit Grace Mejiro McQueen",
    "Sky Ace Mayano Top Gun", "Dark Veil Rice Shower", "Overdrive Tamamo Cross", "Gray Monster Oguri Cap",
    "Summer Golshi", "Cheval Grand",
    -- Top Star Tier
    "TM Opera O", "El Condor Pasa", "Kitasan Black", "Taiki Shuttle", "Mihono", "Manhattan Cafe",
    "Satono Diamond", "Seiun Sky", "Beiun Hayahide"
}

-- Use CHARACTER_DATABASE directly without mutations
local COMPLETE_DATABASE = CHARACTER_DATABASE

local function getSortedCharacters()
    local orderedCharacters = {
        -- Secret Tier
        "Symboli Rudlof", "Gentildonna", "Orfevere",
        -- Legend Tier
        "Shining Star Haru Urara", "Blazing Promise Tokai Teio", "Empress Kitasan Black", "Starlit Grace Mejiro McQueen",
        "Sky Ace Mayano Top Gun", "Dark Veil Rice Shower", "Overdrive Tamamo Cross", "Gray Monster Oguri Cap",
        "Summer Golshi", "Cheval Grand",
        -- Top Star Tier
        "TM Opera O", "El Condor Pasa", "Kitasan Black", "Taiki Shuttle", "Mihono", "Manhattan Cafe",
        "Satono Diamond", "Seiun Sky", "Beiun Hayahide",
        -- Platinum Tier
        "Gold Ship", "Tokai Teio", "Daiwa Scarlet", "Jungle Pocket", "Rice Shower", "Oguri Cap",
        "Nice Nature", "Twin Turbo", "Meisho Doto", "Maruzensky", "Silence Suzuka", "Super Creek",
        "Mejiro McQueen", "Special Week", "Hishi Amazon", "Uolka", "Grass Wonder",
        -- Gold Tier
        "Mambo", "Haru Urara", "Myano Top Gun", "Agnes Taychon", "Sakura Bakushin O", "Tamamo Cross",
        -- Silver Tier
        "Academy Daiwa Scarlet", "Academy Gold Ship", "Academy Taiki Shuttle", "Academy Agnes Tachyon",
        "Academy TM Opera O", "Academy Mejiro McQueen",
        -- Bronze Tier
        "Academy Tamamo Cross", "Academy El Condor Pasa", "Academy Onguri Cap", "Academy Myano Top Gun",
        -- Beginner Tier
        "Academy Haru Urara", "Academy Mambo", "Academy Sakura Bokushin O",
        -- Silver Tier (including temporary)
        "Carrot Haru", "Amazon Delivery", "Starbucks Cafe",
        -- Gold Tier (including temporary)
        "Normal Week", "MaruStappen",
        -- Platinum Tier (including temporary)
        "Doom Slayer Suzuka", "Kitasan Wick", "Chubby Oguri",
        -- Star Tier (temporary)
        "Colonel Ship", "Hachimi Teio",
        -- Top Star Tier (including temporary)
        "Squid Game Rice Shower", "Super Freak", "Mean Nature",
        -- Legend Tier (including temporary)
        "Honored Agnes", "Bakushin West",
        -- Secret Tier (including temporary)
        "World Over Heaven Haru", "An Actual Horse"
    }
    
    for name, data in pairs(COMPLETE_DATABASE) do
        if not data.tier then
            local tierMap = {Secret = 1, Legend = 2, ["Top Star"] = 3, Star = 3, Platinum = 4, Gold = 5, Silver = 6, Bronze = 7, Beginner = 8}
            data.tier = tierMap[data.rarity] or 9
        end
        if not data.baseChar then
            data.baseChar = name
        end
    end
    
    local finalList = {}
    for _, charName in ipairs(orderedCharacters) do
        if COMPLETE_DATABASE[charName] then
            table.insert(finalList, charName)
        end
    end
    
    for name, _ in pairs(COMPLETE_DATABASE) do
        local found = false
        for _, orderedName in ipairs(orderedCharacters) do
            if orderedName == name then
                found = true
                break
            end
        end
        if not found then
            table.insert(finalList, name)
        end
    end
    
    return finalList
end

local characterNames = getSortedCharacters()
local gameData

-- Safe save helper
local function safeSave()
    if DataManager and DataManager.save and gameData then
        pcall(function()
            DataManager:save(gameData)
        end)
    else
        warn("safeSave: DataManager.save or gameData not available")
    end
end

-- Enhanced Auto Buy System with purchase tracking and re-purchase detection
local AutoBuySystem = {
    active = false,
    currentTarget = nil,
    currentTargetName = nil,
    purchasedCharacters = {},
    purchaseInProgress = {},
    characterInstances = {},  
    movementTracking = {},    
    spawnLocationCache = {},   
    lastTargetUpdate = 0,
    lastRebuyTarget = nil,
    promptFiredBy = {},  
    promptConnections = {}  
}

-- Get player's spawn location
local function getPlayerSpawnLocation()
    local player = Services.Players.LocalPlayer
    return player.RespawnLocation or workspace:FindFirstChild("SpawnLocation" .. player.Name)
end

-- Get all other spawn locations (excluding player's)
local function getOtherSpawnLocations()
    local playerSpawn = getPlayerSpawnLocation()
    local otherSpawns = {}
    
    for _, spawnName in ipairs(SPAWN_LOCATIONS) do
        local spawn = workspace:FindFirstChild(spawnName)
        if spawn and spawn ~= playerSpawn then
            table.insert(otherSpawns, spawn)
        end
    end
    
    return otherSpawns
end

-- Enhanced movement tracking for characters
local function trackCharacterMovement(character)
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
    
    local uid = nil
    pcall(function()
        uid = getCharacterUID(character)
    end)
    
    if not uid then return nil end
    
    local now = tick()
    local position = character.HumanoidRootPart.Position
    
    -- Initialize movementTracking table if it doesn't exist
    if not AutoBuySystem.movementTracking then
        AutoBuySystem.movementTracking = {}
    end
    
    if not AutoBuySystem.movementTracking[uid] then
        AutoBuySystem.movementTracking[uid] = {
            positions = {},
            lastUpdate = now,
            isMoving = false,
            direction = nil,
            targetSpawn = nil
        }
    end
    
    local tracking = AutoBuySystem.movementTracking[uid]
    
    -- Update position history
    table.insert(tracking.positions, {position = position, time = now})
    
    -- Keep only recent positions (last 5 seconds)
    while #tracking.positions > 0 and (now - tracking.positions[1].time) > 5 do
        table.remove(tracking.positions, 1)
    end
    
    -- Calculate movement
    if #tracking.positions >= 2 then
        local oldPos = tracking.positions[1].position
        local newPos = tracking.positions[#tracking.positions].position
        local distance = (newPos - oldPos).Magnitude
        
        tracking.isMoving = distance > CONFIG.MOVEMENT_THRESHOLD
        
        if tracking.isMoving then
            tracking.direction = (newPos - oldPos).Unit
        end
    end
    
    return tracking
end

-- Check if character is heading towards a specific spawn location
local function isCharacterHeadingToSpawn(character, spawnLocation)
    if not character or not spawnLocation or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    if not spawnLocation.Position then
        return false
    end
    
    local tracking = nil
    pcall(function()
        tracking = trackCharacterMovement(character)
    end)
    
    if not tracking or not tracking.isMoving or not tracking.direction then
        return false
    end
    
    local charPos = character.HumanoidRootPart.Position
    local spawnPos = spawnLocation.Position
    local distanceToSpawn = (spawnPos - charPos).Magnitude
    
    -- If too far away, not heading there
    if distanceToSpawn > CONFIG.SPAWN_CHECK_DISTANCE then
        return false
    end
    
    -- Calculate direction to spawn
    local directionToSpawn = (spawnPos - charPos).Unit
    
    -- Check if movement direction aligns with spawn direction (dot product > 0.7 means roughly same direction)
    local alignment = tracking.direction:Dot(directionToSpawn)
    
    return alignment > 0.7 and distanceToSpawn < CONFIG.SPAWN_CHECK_DISTANCE
end

-- Purchase detection using proximity prompt event monitoring
function AutoBuySystem:isCharacterPurchasedByOther(character)
    if not character or not character.Parent then return false end
    if not character:FindFirstChild("HumanoidRootPart") then return false end
    
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
    if not torso then return false end
    
    local prompt = torso:FindFirstChild("BuyPrompt") or torso:FindFirstChild("BuyPromptOLD")
    if not prompt or not prompt:IsA("ProximityPrompt") then return false end
    
    -- Use robust UID generation that never returns nil
    local uid = character.Name .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
    
    -- Check if someone else fired this prompt (not us)
    if self.promptFiredBy[uid] and self.promptFiredBy[uid] ~= player then
        print("üîç PURCHASE DETECTED: " .. character.Name .. " bought by " .. tostring(self.promptFiredBy[uid]))
        return true
    end
    
    -- Check if proximity prompt is disabled (backup method)
    if not prompt.Enabled then
        -- If we didn't fire it, someone else did
        if not self.promptFiredBy[uid] or self.promptFiredBy[uid] ~= player then
            print("üîç PURCHASE DETECTED: " .. character.Name .. " prompt disabled by other player")
            return true
        end
    end
    
    return false
end

-- Helper function to get unique character identifier
local function getCharacterUID(character)
    if not character then return nil end
    if not character.Parent then return nil end
    if not character.Name then return nil end
    
    local creationTime = nil
    pcall(function()
        creationTime = character:GetAttribute("CreationTime")
    end)
    
    if not creationTime then
        local success, guid = pcall(function()
            return Services.HttpService:GenerateGUID(false)
        end)
        
        if success and guid then
            creationTime = guid
        else
            local pos = character:FindFirstChild("HumanoidRootPart")
            local posString = "nopos"
            if pos and pos.Position then
                pcall(function()
                    posString = string.format("%.2f_%.2f_%.2f", pos.Position.X, pos.Position.Y, pos.Position.Z)
                end)
            end
            creationTime = tostring(tick()) .. "_" .. posString .. "_" .. tostring(math.random(10000, 99999))
        end
        
        if creationTime then
            pcall(function()
                character:SetAttribute("CreationTime", creationTime)
            end)
        end
    end
    
    if not creationTime then
        -- Final fallback if everything fails
        creationTime = tostring(tick()) .. "_fallback"
    end
    
    return character.Name .. "_" .. tostring(creationTime)
end

-- Check if character was purchased by us specifically
local function isCharacterPurchasedByUs(character)
    -- Use robust UID generation that never returns nil
    local uid = character.Name .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
    
    -- Check if we marked this specific instance as purchased
    local purchaseData = AutoBuySystem.purchasedCharacters[uid]
    if purchaseData and character.Parent == workspace then
        return true
    end
    
    -- Check if we're currently trying to purchase it
    if AutoBuySystem.purchaseInProgress[uid] then
        return true
    end
    
    -- Clean up stale purchase records
    if purchaseData and character.Parent ~= workspace then
        AutoBuySystem.purchasedCharacters[uid] = nil
        if AutoBuySystem.characterInstances[character.Name] then
            AutoBuySystem.characterInstances[character.Name][uid] = nil
        end
    end
    
    return false
end

-- Enhanced function to detect if a character respawned after being purchased by someone else
local function detectCharacterRespawn(characterName)
    if not AutoBuySystem.characterInstances[characterName] then return false end
    
    -- Get current instances in workspace
    local currentInstances = {}
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:IsA("Model") and obj.Name == characterName then
            local uid = getCharacterUID(obj)
            if uid then
                currentInstances[uid] = obj
            end
        end
    end
    
    -- Check if any previously tracked instances are missing
    local respawnDetected = false
    for trackedUID, data in pairs(AutoBuySystem.characterInstances[characterName]) do
        if not currentInstances[trackedUID] and data.character.Parent ~= workspace then
            -- This instance disappeared, likely bought by someone else
            -- Clear our records for this instance
            AutoBuySystem.purchasedCharacters[trackedUID] = nil
            AutoBuySystem.characterInstances[characterName][trackedUID] = nil
            respawnDetected = true
            print("üîç Detected " .. characterName .. " was bought by someone else - cleared purchase record")
        end
    end
    
    -- Update our tracked instances to current ones
    for uid, obj in pairs(currentInstances) do
        if not AutoBuySystem.characterInstances[characterName][uid] then
            -- New instance appeared
            AutoBuySystem.characterInstances[characterName][uid] = {
                character = obj,
                firstSeen = tick()
            }
        end
    end
    
    return respawnDetected
end

-- Check if character has already been purchased (enhanced version)
local function isCharacterPurchased(character)
    -- Check if we purchased this character
    if isCharacterPurchasedByUs(character) then
        return true
    end
    
    -- Check if someone else purchased this character
    if AutoBuySystem:isCharacterPurchasedByOther(character) then
        return true
    end
    
    return false
end

-- Mark character as purchased (enhanced version)
local function markCharacterPurchased(character, success)
    local uid = getCharacterUID(character)
    if not uid then return end
    
    if success then
        AutoBuySystem.purchasedCharacters[uid] = {
            timestamp = tick(),
            characterName = character.Name,
            purchaseTime = os.time(),
            characterInstance = character  -- Keep reference to the specific instance
        }
        
        -- Update our instance tracking
        if not AutoBuySystem.characterInstances[character.Name] then
            AutoBuySystem.characterInstances[character.Name] = {}
        end
        AutoBuySystem.characterInstances[character.Name][uid] = {
            character = character,
            purchased = true,
            purchaseTime = tick()
        }
        
        AutoBuySystem.purchaseInProgress[uid] = nil
        print("‚úÖ Successfully purchased: " .. character.Name .. " (UID: " .. uid:sub(-8) .. ")")
        
        -- Clean up old purchase records after 5 minutes
        spawn(function()
            task.wait(300)
            if AutoBuySystem.purchasedCharacters[uid] then
                AutoBuySystem.purchasedCharacters[uid] = nil
            end
        end)
    else
        AutoBuySystem.purchaseInProgress[uid] = nil
        print("‚ùå Failed to purchase: " .. character.Name)
    end
    
    -- Clean up old tracking data
    local currentTime = tick()
    for storedUID, data in pairs(AutoBuySystem.purchasedCharacters) do
        if type(data) == "table" and data.timestamp and (currentTime - data.timestamp) > 600 then
            AutoBuySystem.purchasedCharacters[storedUID] = nil
        end
    end
end

-- Mark character as being purchased
local function markCharacterInProgress(character)
    local uid = getCharacterUID(character)
    if not uid then return false end
    
    if AutoBuySystem.purchaseInProgress[uid] then
        return false
    end
    
    AutoBuySystem.purchaseInProgress[uid] = {
        timestamp = tick(),
        characterName = character.Name
    }
    
    spawn(function()
        task.wait(15)
        if AutoBuySystem.purchaseInProgress[uid] then
            AutoBuySystem.purchaseInProgress[uid] = nil
        end
    end)
    
    return true
end

-- Enhanced purchase function with duplicate prevention
local function attemptPurchase(localPlayer, targetCharacter)
    if not targetCharacter or not targetCharacter.Parent then
        return false
    end
    
    if isCharacterPurchased(targetCharacter) then
        return false
    end
    
    -- Double-check if character is heading to another spawn before purchase
    if AutoBuySystem:isCharacterPurchasedByOther(targetCharacter) then
        print("üö´ Aborting purchase - character heading to another spawn: " .. targetCharacter.Name)
        return false
    end
    
    if not markCharacterInProgress(targetCharacter) then
        return false
    end
    
    print("üõí Attempting to purchase: " .. targetCharacter.Name)
    
    local torso = targetCharacter:FindFirstChild("Torso") or targetCharacter:FindFirstChild("HumanoidRootPart")
    if not torso then 
        warn("[AutoBuy] No torso/HumanoidRootPart found on target: " .. targetCharacter.Name)
        markCharacterPurchased(targetCharacter, false)
        return false 
    end
    
    local prompt = torso:FindFirstChild("BuyPrompt") or torso:FindFirstChild("BuyPromptOLD")
    if not prompt or not prompt:IsA("ProximityPrompt") then
        warn("[AutoBuy] No valid proximity prompt found on: " .. targetCharacter.Name)
        markCharacterPurchased(targetCharacter, false)
        return false
    end
    
    -- Check if prompt is still enabled (not purchased by someone else)
    if not prompt.Enabled then
        print("‚ö†Ô∏è Purchase prompt disabled - someone else bought: " .. targetCharacter.Name)
        markCharacterPurchased(targetCharacter, false)
        return false
    end
    
    if humanoidRootPart and torso then
        local distance = (humanoidRootPart.Position - torso.Position).Magnitude
        if distance > CONFIG.AUTO_BUY_DISTANCE * 1.5 then
            warn("[AutoBuy] Too far from target: " .. targetCharacter.Name .. " (distance: " .. math.floor(distance) .. ")")
            markCharacterPurchased(targetCharacter, false)
            return false
        end
    end
    
    -- Single attempt to prevent money drain
    local purchaseSuccess = false
    local success = pcall(function()
        fireproximityprompt(prompt)
        purchaseSuccess = true
    end)
    
    if success and purchaseSuccess then
        print("üéØ Purchase successful: " .. targetCharacter.Name)
        markCharacterPurchased(targetCharacter, true)
        return true
    else
        warn("[AutoBuy] Failed to purchase: " .. targetCharacter.Name)
        markCharacterPurchased(targetCharacter, false)
        return false
    end
end

function AutoBuySystem:isCurrentTargetEnabled()
    if not self.currentTargetName then
        return true
    end
    
    return gameData.characters[self.currentTargetName] and gameData.characters[self.currentTargetName].enabled
end

function AutoBuySystem:toggle()
    self.active = not self.active
    gameData.settings.autoBuyEnabled = self.active
    
    if self.active then
        print("üéÜ Auto Buy system STARTED (Enhanced)")
        self:setupPromptMonitoring()
        spawn(function()
            self:mainLoop()
        end)
    else
        print("üõë Auto Buy system STOPPED")
        self:cleanupPromptMonitoring()
        self.currentTarget = nil
        self.currentTargetName = nil
        if humanoid then
            humanoid:MoveTo(humanoidRootPart.Position)
        end
    end

    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

-- Setup proximity prompt monitoring to detect who fires prompts
function AutoBuySystem:setupPromptMonitoring()
    print("üîç Setting up proximity prompt monitoring...")
    
    -- Monitor all existing characters
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:IsA("Model") and COMPLETE_DATABASE[obj.Name] then
            self:monitorCharacterPrompt(obj)
        end
    end
    
    -- Monitor new characters as they spawn
    self.workspaceConnection = workspace.ChildAdded:Connect(function(child)
        if child:IsA("Model") and COMPLETE_DATABASE[child.Name] then
            task.wait(0.1) -- Small delay to ensure prompt is loaded
            self:monitorCharacterPrompt(child)
        end
    end)
end

-- Monitor a specific character's proximity prompt
function AutoBuySystem:monitorCharacterPrompt(character)
    if not character or not character.Parent then return end
    
    local torso = character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
    if not torso then return end
    
    local prompt = torso:FindFirstChild("BuyPrompt") or torso:FindFirstChild("BuyPromptOLD")
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    
    -- Use robust UID generation that never returns nil
    local uid = character.Name .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
    
    -- Clean up existing connection if any
    if self.promptConnections[uid] then
        self.promptConnections[uid]:Disconnect()
    end
    
    -- Monitor prompt triggered event
    self.promptConnections[uid] = prompt.Triggered:Connect(function(playerWhoTriggered)
        self.promptFiredBy[uid] = playerWhoTriggered
        
        if playerWhoTriggered == player then
            print("‚úÖ We fired prompt for: " .. character.Name)
        else
            print("üîç Other player (" .. playerWhoTriggered.Name .. ") fired prompt for: " .. character.Name)
        end
        
        -- Clean up after 30 seconds
        task.delay(30, function()
            if self.promptFiredBy[uid] then
                self.promptFiredBy[uid] = nil
            end
        end)
    end)
    
    -- Clean up connection when character is removed
    character.AncestryChanged:Connect(function()
        if not character.Parent and self.promptConnections[uid] then
            self.promptConnections[uid]:Disconnect()
            self.promptConnections[uid] = nil
        end
    end)
end

-- Cleanup proximity prompt monitoring
function AutoBuySystem:cleanupPromptMonitoring()
    print("üßπ Cleaning up proximity prompt monitoring...")
    
    -- Disconnect workspace connection
    if self.workspaceConnection then
        self.workspaceConnection:Disconnect()
        self.workspaceConnection = nil
    end
    
    -- Disconnect all prompt connections
    for uid, connection in pairs(self.promptConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    -- Clear tracking data
    self.promptConnections = {}
    self.promptFiredBy = {}
end

function AutoBuySystem:findBestTarget()
    local bestTarget = nil
    local bestScore = -math.huge
    local now = tick()
    
    if now - self.lastTargetUpdate < 0.8 then
        return bestTarget, bestScore
    end
    
    self.lastTargetUpdate = now
    
    for _, charName in ipairs(characterNames) do
        local charData = COMPLETE_DATABASE[charName]
        local trackData = gameData.characters[charName]
        
        if not trackData.enabled then continue end
        
        -- Run respawn detection for this character type
        detectCharacterRespawn(charName)
        
        local target = workspace:FindFirstChild(charName)
        if target and target:IsA("Model") and target:FindFirstChild("HumanoidRootPart") then
            if isCharacterPurchased(target) then continue end
            
            -- Check if character is heading to another player's spawn (purchased by someone else)
            if self:isCharacterPurchasedByOther(target) then continue end
            
            local torso = target:FindFirstChild("Torso") or target:FindFirstChild("HumanoidRootPart")
            if not torso then continue end
            
            local prompt = torso:FindFirstChild("BuyPrompt") or torso:FindFirstChild("BuyPromptOLD")
            if not prompt or not prompt:IsA("ProximityPrompt") then continue end
            
            local distance = (humanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
            
            -- Priority based on income per second
            local incomeScore = charData.income or 0
            local distancePenalty = distance * 10
            local proximityBonus = math.max(0, (50 - distance) * 5)
            
            local score = incomeScore + proximityBonus - distancePenalty
            
            if score > bestScore then
                bestScore = score
                bestTarget = target
            end
        end
    end
    
    return bestTarget, bestScore
end

function AutoBuySystem:followTarget(target)
    if not target or not target.Parent then return false end
    if isCharacterPurchased(target) then return false end

    if humanoid and humanoid.WalkSpeed ~= 21 then
        humanoid.WalkSpeed = 21
    end

    local startTime = tick()
    local targetName = target.Name
    self.currentTargetName = targetName

    print("üéØ Following target: " .. targetName)

    while self.active and target.Parent and (tick() - startTime) < CONFIG.MAX_FOLLOW_TIME do
        if not self:isCurrentTargetEnabled() then
            self.currentTarget = nil
            self.currentTargetName = nil
            if humanoid then
                humanoid:MoveTo(humanoidRootPart.Position)
            end
            print("‚ùå Target disabled during follow: " .. targetName)
            return false
        end

        if isCharacterPurchased(target) then
            print("‚úÖ Target already purchased: " .. targetName)
            return false
        end

        -- INSTANT REBUY CHECK - Check if someone else bought it
        if self:isCharacterPurchasedByOther(target) then
            print("‚ö° INSTANT REBUY TRIGGERED for: " .. targetName)
            print("üîÑ " .. targetName .. " was bought by someone else - clearing purchase record")
            
            -- Clear this character from purchased list so we can buy it again if it respawns
            local uid = getCharacterUID(target)
            if uid and self.purchasedCharacters[uid] then
                self.purchasedCharacters[uid] = nil
                print("‚úÖ Cleared purchase record for " .. targetName .. " - can rebuy if respawns")
            end
            
            self.currentTarget = nil
            self.currentTargetName = nil
            return "rebuy" -- Signal for immediate rebuy
        end

        if not target.Parent or not target:FindFirstChild("HumanoidRootPart") then
            print("‚ùå Target became invalid: " .. targetName .. " - stopping follow")
            return false
        end

        local distance = (humanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude

        if distance <= CONFIG.AUTO_BUY_DISTANCE then
            if target.Name ~= targetName then
                print("‚ùå Target name mismatch during purchase")
                return false
            end
            
            print("üí∞ In range, attempting purchase: " .. targetName)
            local success = attemptPurchase(player, target)
            if success then
                task.wait(1) -- Reduced from 3 to 1 second for faster rebuy
                return true
            else
                print("‚ùå Purchase failed for: " .. targetName)
                task.wait(0.5) -- Reduced from 2 to 0.5 seconds
                return false
            end
        end

        humanoid:MoveTo(target.HumanoidRootPart.Position)
        task.wait(0.1) -- Reduced from 0.15 to 0.1 for faster response
    end

    if tick() - startTime >= CONFIG.MAX_FOLLOW_TIME then
        print("‚è∞ Follow timeout for: " .. targetName)
    end

    self.currentTargetName = nil
    return false
end

function AutoBuySystem:mainLoop()
    print("üîÑ Auto Buy main loop started (Enhanced)")
    
    while self.active do
        if not self:isCurrentTargetEnabled() then
            self.currentTarget = nil
            self.currentTargetName = nil
            if humanoid then
                humanoid:MoveTo(humanoidRootPart.Position)
            end
            task.wait(1)
            continue
        end
        
        local target, score = self:findBestTarget()
        
        if target then
            print("üéØ New best target found: " .. target.Name .. " (score: " .. math.floor(score) .. ")")
            self.currentTarget = target
            
            -- Check if this target is the same as the one we just detected as bought by someone else
            if self.lastRebuyTarget and self.lastRebuyTarget == target then
                print("‚ö†Ô∏è Skipping same target that triggered rebuy: " .. target.Name)
                self.lastRebuyTarget = nil
                task.wait(0.5)
                continue
            end
            
            local result = self:followTarget(target)
            
            if result == true then
                print("‚úÖ Successfully purchased: " .. target.Name)
                self.purchasedCharacters[getCharacterUID(target)] = tick()
            elseif result == "rebuy" then
                print("üîÑ INSTANT REBUY TRIGGERED - Someone else bought " .. target.Name .. "!")
                print("üîç DEBUG: Starting rebuy process...")
                
                -- Mark the current target as purchased so we don't target it again
                local oldUID = getCharacterUID(target)
                self.purchasedCharacters[oldUID] = tick()
                
                self.currentTarget = nil
                self.currentTargetName = nil
                
                print("üîÑ Restarting auto-buy loop to find new target...")
                task.wait(0.1) -- Small delay then continue main loop
                continue
            end
        else
            self.currentTargetName = nil
            -- Clean up old tracking data periodically
            local currentTime = tick()
            for characterName, instances in pairs(self.characterInstances) do
                for uid, data in pairs(instances) do
                    if data.timestamp and (currentTime - data.timestamp) > 300 then
                        instances[uid] = nil
                    end
                end
            end
            if humanoid then
                humanoid:MoveTo(humanoidRootPart.Position)
            end
        end
        
        task.wait(0.5) -- Quick loop for instant rebuy
    end
    
    print("üõë Auto Buy main loop stopped")
end

-- Lock door function
local function lockDoor()
    local lockerRoom = getPlayerLockerRoom()
    if not lockerRoom then return end

    local buttons = lockerRoom:FindFirstChild("Buttons")
    if not buttons then return end

    local lockButton = buttons:FindFirstChild("DoorLockButton")
    if not lockButton then return end

    local success = false
    
    local buttonPart = lockButton:FindFirstChild("ButtonPressPartOO") or lockButton:FindFirstChild("Part")
    if buttonPart then
        local clickDetector = buttonPart:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            pcall(function()
                fireclickdetector(clickDetector)
                success = true
            end)
            if success then return end
        end
        
        local proximityPrompt = buttonPart:FindFirstChildOfClass("ProximityPrompt")
        if proximityPrompt then
            pcall(function()
                fireproximityprompt(proximityPrompt)
                success = true
            end)
            if success then return end
        end
        
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            pcall(function()
                firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 0)
                task.wait(0.1)
                firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 1)
                success = true
            end)
        end
    end
    
    if not success then
        local directPrompt = lockButton:FindFirstChildOfClass("ProximityPrompt") or lockButton:FindFirstChildOfClass("ClickDetector")
        if directPrompt then
            pcall(function()
                if directPrompt:IsA("ProximityPrompt") then
                    fireproximityprompt(directPrompt)
                elseif directPrompt:IsA("ClickDetector") then
                    fireclickdetector(directPrompt)
                end
                success = true
            end)
        end
    end
end

--- Collect cash function for Umamusume game using correct paths
local function collectAllCash()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local collected = 0
    local attempted = 0
    
    -- Use the correct path: workspace.Map.Rooms.LockerRoom[PlayerNumber].Lockers.Locker[Number].CollectButton
    local map = workspace:FindFirstChild("Map")
    if not map then return end
    
    local rooms = map:FindFirstChild("Rooms")
    if not rooms then return end
    
    -- Find player's locker room
    local playerSpawn = getPlayerSpawnLocation()
    if not playerSpawn then return end
    
    local playerNumber = playerSpawn.Name:match("%d+")
    if not playerNumber then return end
    
    local lockerRoom = rooms:FindFirstChild("LockerRoom" .. playerNumber)
    if not lockerRoom then return end
    
    local lockers = lockerRoom:FindFirstChild("Lockers")
    if not lockers then return end
    
    -- Collect from all lockers in the player's room
    for _, locker in pairs(lockers:GetChildren()) do
        if locker.Name:match("Locker%d+") then
            local collectButton = locker:FindFirstChild("CollectButton")
            if collectButton then
                attempted = attempted + 1
                local lockerCollected = false
                
                -- Use touch interest on CollectButton for Umamusume game
                pcall(function()
                    firetouchinterest(collectButton, player.Character.HumanoidRootPart, 0)
                    task.wait(0.05)
                    firetouchinterest(collectButton, player.Character.HumanoidRootPart, 1)
                    lockerCollected = true
                    collected = collected + 1
                end)
                
                if lockerCollected then
                    task.wait(0.02)
                end
            end
        end
    end
    
    if collected > 0 then
        AutoCollect.totalCollected = (AutoCollect.totalCollected or 0) + collected
        AutoCollect.collectionsThisSession = (AutoCollect.collectionsThisSession or 0) + collected
    end
end

-- Auto Lock System
local AutoLock = {
    active = false,
    connection = nil,
    interval = 1,
    timer = 0,
    lastLogTime = 0,
    successfulLocks = 0
}

function AutoLock:toggle()
    self.active = not self.active
    gameData.settings.autoLockEnabled = self.active

    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end

    if self.active then
        print("Auto Lock system STARTED")
        lockDoor()
        self.timer = 0
        self.lastLogTime = 0
        self.successfulLocks = 0
        
        self.connection = Services.RunService.Heartbeat:Connect(function(dt)
            self.timer = (self.timer or 0) + dt
            if self.timer >= self.interval then
                if self.active then
                    lockDoor()
                end
                self.timer = 0
            end
        end)
    else
        print("Auto Lock system STOPPED")
        self.successfulLocks = 0
    end

    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

function AutoLock:forceStop()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
    self.active = false
    gameData.settings.autoLockEnabled = false
    print("Auto Lock system FORCE STOPPED")
    self.successfulLocks = 0
end

-- Auto Collect System
local AutoCollect = {
    active = false,
    connection = nil,
    interval = 0.5,
    timer = 0,
    lastLogTime = 0,
    totalCollected = 0,
    collectionsThisSession = 0
}

function AutoCollect:toggle()
    self.active = not self.active
    gameData.settings.autoCollectEnabled = self.active

    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end

    if self.active then
        print("Auto Collect system STARTED")
        collectAllCash()
        self.timer = 0
        self.lastLogTime = 0
        self.totalCollected = 0
        self.collectionsThisSession = 0
        
        self.connection = Services.RunService.Heartbeat:Connect(function(dt)
            self.timer = (self.timer or 0) + dt
            if self.timer >= self.interval then
                if self.active then
                    collectAllCash()
                end
                self.timer = 0
            end
        end)
    else
        print("Auto Collect system STOPPED")
        self.totalCollected = 0
        self.collectionsThisSession = 0
    end

    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

function AutoCollect:forceStop()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
    self.active = false
    gameData.settings.autoCollectEnabled = false
    print("Auto Collect system FORCE STOPPED")
    self.totalCollected = 0
    self.collectionsThisSession = 0
end

DataManager = {
    cache = {},
    saveQueue = nil,
    lastSave = 0,
    saveInProgress = false,
    currentAccount = nil,
    accountHash = nil
}

function DataManager:generateAccountHash()
    local userId = tostring(player.UserId)
    local userName = player.Name
    local displayName = player.DisplayName or userName

    local hashString = userId .. "_" .. userName .. "_" .. displayName

    local hash = ""
    for i = 1, #hashString do
        hash = hash .. string.format("%02x", string.byte(hashString, i))
    end

    self.accountHash = string.sub(hash, 1, 16)
    self.currentAccount = userName .. "_" .. userId

    print("[DataManager] Account identified as: " .. self.currentAccount)
    print("[DataManager] Account hash: " .. self.accountHash)
end

function DataManager:getBasePath()
    local paths = {
        function() return getexecutordirectory() .. "/UnluckysVision" end,
        function() return getscriptsdirectory() .. "/../UnluckysVision" end,
        function() return "UnluckysVision" end
    }
    for _, pathFunc in ipairs(paths) do
        local success, path = pcall(pathFunc)
        if success and path then return path end
    end
    return "UnluckysVision"
end

function DataManager:getAccountPath()
    if not self.accountHash then
        self:generateAccountHash()
    end

    local basePath = self:getBasePath()
    return basePath .. "/accounts/" .. self.accountHash
end

function DataManager:getDataPath()
    return self:getAccountPath() .. "/gamedata.json"
end

function DataManager:createDirectories()
    local basePath = self:getBasePath()
    local accountPath = self:getAccountPath()

    local dirs = {
        basePath,
        basePath .. "/accounts",
        accountPath,
        accountPath .. "/backups",
        accountPath .. "/exports",
        basePath .. "/shared"
    }

    for _, dir in ipairs(dirs) do
        local success, error = pcall(function()
            makefolder(dir)
        end)
        if not success then
            warn("[DataManager] Could not create directory: " .. dir .. " - " .. tostring(error))
        end
    end

    self:saveAccountInfo()
end

function DataManager:saveAccountInfo()
    local accountInfoPath = self:getAccountPath() .. "/account_info.json"
    local accountInfo = {
        userId = player.UserId,
        userName = player.Name,
        displayName = player.DisplayName or player.Name,
        accountHash = self.accountHash,
        createdAt = os.time(),
        lastAccessed = os.time(),
        version = "1.0"
    }

    pcall(function()
        local jsonData = Services.HttpService:JSONEncode(accountInfo)
        writefile(accountInfoPath, jsonData)
    end)
end

function DataManager:updateLastAccessed()
    local accountInfoPath = self:getAccountPath() .. "/account_info.json"

    local success, content = pcall(function() return readfile(accountInfoPath) end)
    if success and content then
        local parseSuccess, accountInfo = pcall(function()
            return Services.HttpService:JSONDecode(content)
        end)

        if parseSuccess and accountInfo then
            accountInfo.lastAccessed = os.time()

            pcall(function()
                local jsonData = Services.HttpService:JSONEncode(accountInfo)
                writefile(accountInfoPath, jsonData)
            end)
        end
    end
end

function DataManager:getDefaultData()
    local data = {
        account = {
            userId = player.UserId,
            userName = player.Name,
            displayName = player.DisplayName or player.Name,
            accountHash = self.accountHash,
            dataVersion = "1.0"
        },
        characters = {},
        settings = {
            soundEnabled = true,
            performanceMode = false,
            autoBuyEnabled = false,
            autoLockEnabled = false,
            autoCollectEnabled = false
        },
        analytics = {
            totalSpawns = 0,
            sessionStart = os.time(),
            bestSession = {spawns = 0, duration = 0},
            rarityStats = {},
            totalPlayTime = 0
        },
        filters = {
            searchText = "",
            exactMatch = false,
            selectedRarity = nil,
            enabledOnly = false
        }
    }

    for _, name in ipairs(characterNames) do
        local isDefaultEnabled = false
        for _, defaultName in ipairs(DEFAULT_ENABLED_CHARACTERS) do
            if name == defaultName then
                isDefaultEnabled = true
                break
            end
        end
        data.characters[name] = {
            enabled = isDefaultEnabled,
            totalSeen = 0,
            currentCount = 0,
            status = "never",
            lastSeen = 0,
            sessionSpawns = 0,
            totalTime = 0,
            detectedThisSession = false
        }
    end

    return data
end
{{ ... }}

            for _, charName in ipairs(characterNames) do
                -- Ensure character entry exists
                local trackData = gameData.characters[charName]
                if not trackData then
                    gameData.characters[charName] = {
                        enabled = false,
                        totalSeen = 0,
                        currentCount = 0,
                        status = "never",
                        lastSeen = 0,
                        sessionSpawns = 0,
                        totalTime = 0,
                        detectedThisSession = false
                    }
                    trackData = gameData.characters[charName]
                end

                if trackData.enabled then
                    local currentCount = self:getCharacterCount(charName)
                    if currentCount > 0 then
                        -- Always update last seen when character is present
                        trackData.lastSeen = os.time()
                        
                        if trackData.status ~= "active" then
                            trackData.status = "active"
                            -- Only increment session spawns when first detected in this session
                            if not trackData.detectedThisSession then
                                trackData.sessionSpawns = (trackData.sessionSpawns or 0) + 1
                                trackData.detectedThisSession = true
                            end
                            trackData.totalSeen = trackData.totalSeen + 1
                            
                            -- Send webhook notification for character spawn
                            local charData = COMPLETE_DATABASE[charName]
                            if charData and charData.rarity then
                                local rarity = charData.rarity
                                if rarity == "Secret" or rarity == "Legend" or rarity == "Top Star" or rarity == "Star" then
                                    WebhookManager:notifyCharacterSpawn(charName, rarity, game.JobId)
                                end
                            end
                        end
                        trackData.currentCount = currentCount
                        trackData.totalTime = trackData.totalTime + deltaTime
                    else
                        if trackData.status ~= "inactive" then
                            trackData.status = "inactive"
                        end
                        trackData.currentCount = 0
                    end
                else
                    trackData.status = "disabled"
                    trackData.currentCount = 0
                end
{{ ... }}
                -- Live-update the UI row if present
                self:updateCharacterUI(charName)
            end

            DataManager:save(gameData)
        end

        function CharacterTracker:updateCharacterUI(charName)
            local trackData = gameData.characters[charName]
            local charData = COMPLETE_DATABASE[charName]
            local row = UIManager.elements.trackingRows[charName]
            if not row or not trackData or not charData then return end

            local statusColor
            if trackData.status == "active" then
                statusColor = Color3.fromRGB(76, 175, 80)      -- green
            elseif trackData.status == "inactive" then
                statusColor = Color3.fromRGB(244, 67, 54)      -- red
            else
                statusColor = Color3.fromRGB(158, 158, 158)    -- gray (disabled/never)
            end
            row.statusDot.BackgroundColor3 = statusColor

            row.labels.current.Text = tostring(trackData.currentCount)
            row.labels.total.Text = tostring(trackData.totalSeen)
            row.labels.session.Text = tostring(trackData.sessionSpawns)

            if trackData.lastSeen > 0 then
                local elapsed = os.time() - trackData.lastSeen
                if elapsed < 60 then
                    row.labels.lastSeen.Text = string.format("%ds", elapsed)
                elseif elapsed < 3600 then
                    row.labels.lastSeen.Text = string.format("%dm", math.floor(elapsed / 60))
                else
                    row.labels.lastSeen.Text = string.format("%dh", math.floor(elapsed / 3600))
                end
            else
                row.labels.lastSeen.Text = "Never"
            end

            -- Priority based on rarity tier (1=highest, 8=lowest)
            local rarityPriority = {
                Secret = 1, Legend = 2, ["Top Star"] = 3, Star = 3, Platinum = 4,
                Gold = 5, Silver = 6, Bronze = 7, Beginner = 8
            }
            local priority = rarityPriority[charData.rarity] or 8
            row.labels.priority.Text = tostring(priority)
        end

        local function initialize()
        print("[UnluckysVision] Initializing...")

        -- Load saved data or fallback to defaults
        gameData = DataManager:load() or DataManager:getDefaultData()

        -- Safety: ensure characters table exists
        gameData.characters = gameData.characters or {}
        
        -- Safety: ensure settings exist with defaults
        gameData.settings = gameData.settings or {}
        gameData.settings.autoLockEnabled = gameData.settings.autoLockEnabled or false
        gameData.settings.autoCollectEnabled = gameData.settings.autoCollectEnabled or false
        gameData.settings.autoBuyEnabled = gameData.settings.autoBuyEnabled or false
        gameData.settings.soundEnabled = gameData.settings.soundEnabled or true
        gameData.settings.performanceMode = gameData.settings.performanceMode or false

        -- Update tracking total based on available character names
        GameState.trackingTotal = #characterNames

        -- Create UI
        UIManager:create()
        UIManager:updateTrackingCount()
        UIManager:updateCharacterList()

        -- Initialize auto systems with saved states
        print("[UnluckysVision] Initializing auto systems...")
        
        if gameData.settings.autoLockEnabled then
            print("[UnluckysVision] Restoring Auto Lock system...")
            AutoLock:toggle()
        end

        if gameData.settings.autoCollectEnabled then
            print("[UnluckysVision] Restoring Auto Collect system...")
            AutoCollect:toggle()
        end
        
        if gameData.settings.autoBuyEnabled then
            print("[UnluckysVision] Restoring Auto Buy system...")
            AutoBuySystem:toggle()
        end

        -- Send script execution notification
        WebhookManager:notifyScriptExecution()

        -- Reset session tracking for new session
        for _, name in ipairs(characterNames) do
            if gameData.characters[name] then
                gameData.characters[name].detectedThisSession = false
                gameData.characters[name].sessionSpawns = 0
            end
        end
        
        -- Delay starting the tracker so UI builds first
        task.delay(0.5, function()
            GameState.scriptActive = true
            CharacterTracker:updateCharacterStates()
            print("[UnluckysVision] Initialization complete.")
            print("[UnluckysVision] Tracking " .. tostring(GameState.trackingEnabled) .. " characters.")
            print("[UnluckysVision] Auto Lock: " .. (gameData.settings.autoLockEnabled and "ON" or "OFF"))
            print("[UnluckysVision] Auto Collect: " .. (gameData.settings.autoCollectEnabled and "ON" or "OFF"))
            print("[UnluckysVision] Auto Buy: " .. (gameData.settings.autoBuyEnabled and "ON" or "OFF"))
        end)
    end

        -- Main update loop to keep tracker and UI refreshed
        local function mainUpdate(deltaTime)
            local now = tick()

            if GameState.scriptActive and (now - GameState.lastUpdate) >= CONFIG.UPDATE_INTERVAL then
                GameState.lastUpdate = now
                GameState.lastUpdateTime = os.time()

                -- Update character states and footer
                CharacterTracker:updateCharacterStates(deltaTime)
                UIManager:updateFooter()
            end

            -- Update performance metrics
            PerformanceMonitor:update(deltaTime)
        end

        -- Connect to RunService.Heartbeat for continuous updates
        Services.RunService.Heartbeat:Connect(function(deltaTime)
            mainUpdate(deltaTime)
        end)

        task.wait(2)
        initialize() 
print("hel")
